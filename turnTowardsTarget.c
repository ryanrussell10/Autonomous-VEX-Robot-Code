#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    turnSensor,     sensorNone)
#pragma config(Sensor, in2,    infraCollector, sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  limitSwitch1,   sensorTouch)
#pragma config(Sensor, dgtl4,  limitSwitch2,   sensorTouch)
#pragma config(Sensor, dgtl5,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  redLED1,        sensorDigitalOut)
#pragma config(Sensor, dgtl9,  redLED2,        sensorDigitalOut)
#pragma config(Sensor, dgtl10, redLED3,        sensorDigitalOut)
#pragma config(Sensor, dgtl11, redLED4,        sensorDigitalOut)
#pragma config(Sensor, I2C_1,  turnEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port3,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           turningMotor,  tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port9,           rightDriveMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftDriveMotor, tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The declaration of states through the use of enumerated types
typedef enum {
	LIGHT_OFF = 0,
	LIGHT_ON,
} T_State;

// A constant value for the light threshold that the phototransistor picks up
const int light_threshold = 200;

// A constant value defined for the wait1MSec function that corresponds to one second
const int oneSecond = 1000;


// Initializes the status of the Red LEDs to OFF
void initLightStatus()
{
  // Turn off the red LED
  SensorValue(redLED1) = 0;
  SensorValue(redLED2) = 0;
  SensorValue(redLED3) = 0;
  SensorValue(redLED4) = 0;
}


// The following two functions are called later in the program:

// Rotates the rear turning wheel with the motor encoder roughly 90 degrees to allow for rotation of the robot
void rotateTurningWheel() {
	motor[turningMotor] = 50;
	wait1Msec(oneSecond);
	motor[turningMotor] = 0;
}

// Straightens the rear turning wheel with the motor encoder after rotation of robot is performed
void straightenTurningWheel() {
	motor[turningMotor] = -50;
	wait1Msec(oneSecond);
	motor[turningMotor] = 0;
}



// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight()
{
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[infraCollector];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

	  // 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

	} else {

	  // Check for new minimum/maximum light levels.
	  if (lightLevel1 < minLevelIR1) {
	  	minLevelIR1 = lightLevel1;
	  } else if (lightLevel1 > maxLevelIR1) {
	    maxLevelIR1 = lightLevel1;
	  }
	}

	// Check if light level difference over threshold.
	if (diffLevelIR1 > light_threshold) {
		returnValue = true;
	} else {
	  returnValue = false;
	}

	// Returns true or false depending on whether or not IR light level is above the threshold
	return(returnValue);
}

task main()
{
	// Initializes the robot state to LIGHT_OFF
	T_State robot_state = LIGHT_OFF;

	// Declares a boolean for whether or not the phototransistor can see the beacon
	bool beaconVisible;

	// Initializes the lights to off
	initLightStatus();

	// Rotates the turning wheel to allow for rotation of the entire robot
	rotateTurningWheel();

	while(true) {

	  // Update sensor values (must be called at least 20 times a second for proper performance).
		beaconVisible = monitorLight();

		switch( robot_state ) {
			case LIGHT_OFF:
				SensorValue[redLED1] = 0;

				// Activate the motors in reverse to each other to rotate the robot until the beacon is detected
				motor[leftDriveMotor] = -30;
				motor[rightDriveMotor] = 30;

				// If the beacon is visible the state is changed
				if (beaconVisible) {
					robot_state = LIGHT_ON;
				} else {
				  robot_state = LIGHT_OFF;
				}
				break;
			case LIGHT_ON:
				SensorValue[redLED1] = 1;

				// Deactivate the motors, stopping the robot facing the target object
				motor[leftDriveMotor] = 0;
    		motor[rightDriveMotor] = 0;

    		// Return the turning wheel to its centred position
    		//straightenTurningWheel();

    		// If the beacon is visible the state is changed
				if (beaconVisible) {
					robot_state = LIGHT_ON;
			  } else {
			    robot_state = LIGHT_OFF;
			  }
			  break;
			default:
				// This should never happen.
			  robot_state = LIGHT_OFF;

		} // switch( robot_state)

	}  // while(true)

}
